drop table board;

create table board(
	board_no int primary key, --글번호
	subject varchar2(30) not null,
	writer varchar2(20) not null,
	content varchar2(50) not null, --내용
	board_date date not null --등록일
); 


--시퀀스 만들기 전에 권한 부여(system계정에서만 가능)
grant  create sequence  to scott;

  
--시퀀스 만들기
create sequence board_seq nocache; 

drop sequence board_seq

select * from board where upper(subject) like upper(?);

commit

insert into board (board_no, subject, writer, content, board_date) 
values (board_seq.nextval, 'db수업', '장희정', '잼난다', sysdate)

insert into board (board_no, subject, writer, content, board_date) 
values (board_seq.nextval, 'db수업2', '이나영', '잼난다', sysdate)

insert into board (board_no, subject, writer, content, board_date) 
values (board_seq.nextval, 'db수업3', '이효리', '잼난다', sysdate)

select * from board order by board_no desc

select * from member;

--댓글
create table reply(
	reply_no number primary key, --댓글번호
	reply_content varchar2(100),  --댓글내용
	board_no number references board(board_no), -- 댓글을 달 부모글 번호
	reply_regdate date  --등록일
);

--댓글에서 사용할 시퀀스 생성
create sequence reply_no_seq nocache;

--샘플 테스트(부모의 1번 글에 댓글을 3개 달아본다.)
select * from board;
select * from reply;

insert into reply values(reply_no_seq.nextval, '1번의 댓글 1', 1, sysdate);
insert into reply values(reply_no_seq.nextval, '1번의 댓글 2', 1, sysdate);
insert into reply values(reply_no_seq.nextval, '1번의 댓글 3', 1, sysdate);

commit

--부모글과 댓글 함께 검색하고 싶다.- join
select *
from board join reply
using(board_no)
--where board_no =1
order by board_no

select * from board where board_no=1  --> BoardDTO

--BoardDTO --> replieslist를 꺼내옴
select * from reply where board_no=1









